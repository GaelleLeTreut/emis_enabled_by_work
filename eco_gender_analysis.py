# -*- coding: utf-8 -*-
"""
Éditeur de Spyder

Ceci est un script temporaire.
"""
import os
import pandas as pd
import statistics as stat
import scipy.stats as st
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import utils as ut
import statsmodels.api as sm
from statsmodels.iolib.summary2 import summary_col
from dbf_into_csv import *
from sklearn.linear_model import LinearRegression
import build_table_survey as bts

##########################
###### Paths 
##########################
output_folder='outputs'
#create output_folder if not exist
if not os.path.exists(output_folder):
    os.makedirs(output_folder)
    print('Creating ' + output_folder + ' to store outputs')
OUTPUTS_PATH = output_folder + os.sep

data_folder = 'data'
DATA_PATH = data_folder + os.sep

this_file = 'eco_gender_analysis.py'
eol='\n'


#######################
# statistical test of independence between branches and wage classes
#######################

#build the frequency matrix if independent
X='A38'
Y='TRNNETO'
cont = bts.full_insee_table[[X,Y]].pivot_table(index=X,columns=Y,aggfunc=len,margins=True,margins_name="Total")
c = cont.fillna(0)
#chi-squared test of independence
# do not include margins in contingency matrix, otherwise the dof are not accurate
st_chi2, st_p, st_dof, st_exp = st.chi2_contingency(c.iloc[:-1,:-1])

##chi2 by hand
##compute the contingency matrix in case of independence
#tx = cont.loc[:,["Total"]]
#ty = cont.loc[["Total"],:]
#n = len(bts.full_insee_table)
#indep = tx.dot(ty) / n
##compute xi2 by hand, ok to include margins, as they are zero here
#measure = (c-indep)**2/indep
#xi_n = measure.sum().sum() #this is the same as st_chi2
##picture the matrix of gap
#table = measure/xi_n
#sns.heatmap(table.iloc[:-1,:-1])#,annot=c.iloc[:-1,:-1])
#plt.show()


#comparison of variance of log of income-based emissions with sums of variance of log of emission content and of log of wages
bts.full_insee_table['log_income-based_emissions'] = np.log(bts.full_insee_table['income-based_emissions'])
bts.full_insee_table['log_emission_content'] = np.log(bts.full_insee_table['emission_content'])
bts.full_insee_table['log_salary_value'] = np.log(bts.full_insee_table['salary_value'])

matrix = np.cov(np.transpose(np.array(bts.full_insee_table[['log_emission_content','log_salary_value']])))
relative_matrix = matrix /np.sum(matrix)
with open(OUTPUTS_PATH+'decomposition_variance.tex','w') as file:
    file.write('% file automatically generated by ' + this_file + eol)
    file.write('% decomposition of variance of log of emission-based' + eol)
    file.write('\\intertext{or in numbers}'+eol)
    file.write("{:.2f}".format(np.sum(matrix)) + " &= " + "{:.2f}".format(matrix[0,0]) +" &&+ " + "{:.2f}".format(matrix[1,1]) + " &&+ 2*" +"{:.2f}".format(matrix[0,1]) + eol)
    file.write('\\intertext{which can also be expressed in relative terms}'+eol)
    file.write("{:.2f}".format(np.sum(relative_matrix)) + " &= " + "{:.2f}".format(relative_matrix[0,0]) +" &&+ " + "{:.2f}".format(relative_matrix[1,1]) + " &&+ 2*" +"{:.2f}".format(relative_matrix[0,1]))

with open(OUTPUTS_PATH+'section_inequalities_numbers.tex','w') as file:
    file.write('% file automatically generated by ' + this_file + eol)
    file.write('% numbers used in main text' + eol)
    file.write('\\newcommand\\relativeratioofvariance{' + "{:.2f}".format(matrix[0,0]/matrix[1,1]) + '} %ratio of variance of log of emissions divided by variance of log of wages' + eol)

#################
# Lorenz and concentration curves
#################

#construct the data for Lorenz curves from grouping by wage classes and branches (because that is all what matters)
bts.full_insee_table['pop_mass']=1
pop_mass_per_sector_x_salary=bts.full_insee_table.groupby(['TRNNETO','A35']).size().reset_index(name='pop_mass')
pop_mass_per_sector_x_salary['emission_content'] = pop_mass_per_sector_x_salary['A35'].replace(bts.dic_to_emission_content_A35)
pop_mass_per_sector_x_salary['salary_value'] = pop_mass_per_sector_x_salary['TRNNETO'].replace(bts.dic_TRNNETO_to_salary)
pop_mass_per_sector_x_salary['salary_mass'] = pop_mass_per_sector_x_salary['salary_value'] * pop_mass_per_sector_x_salary['pop_mass']
pop_mass_per_sector_x_salary['emissions_mass'] = pop_mass_per_sector_x_salary['salary_mass'] * pop_mass_per_sector_x_salary['emission_content']
pop_mass_per_sector_x_salary['emissions_capita'] = pop_mass_per_sector_x_salary['salary_value'] * pop_mass_per_sector_x_salary['emission_content']

ut.make_Lorenz_and_concentration_curves(np.transpose(np.array(pop_mass_per_sector_x_salary[['pop_mass','salary_value', 'emissions_capita']])),{'pop_mass':0,'income':1,'emissions':2},OUTPUTS_PATH + 'Lorenz_curve_French_employee','% data for Lorenz and concentration curves for French employees \n% file automatically created from ' + this_file )


#lowest emitting person
lowest_emitting_person = bts.full_insee_table['income-based_emissions'].idxmin()
#highest emitting person
highest_emitting_person = bts.full_insee_table['income-based_emissions'].idxmax()
#lowest emitting sector 
lowest_emitting_sector = min(bts.dic_to_emission_content_A35, key=bts.dic_to_emission_content_A35.get)
#highest emitting sector 
highest_emitting_sector = max(bts.dic_to_emission_content_A35, key=bts.dic_to_emission_content_A35.get)

with open(OUTPUTS_PATH+'section_inequalities_numbers.tex','a') as file:
    file.write('\\newcommand\\ratioofemissionshighestlowest{' + "{:.0f}".format(bts.full_insee_table.loc[highest_emitting_person, 'income-based_emissions']/bts.full_insee_table.loc[lowest_emitting_person, 'income-based_emissions']) + '}' +eol)
    file.write('\\newcommand\\ratioofwageshighestlowest{' + "{:.0f}".format(bts.full_insee_table.loc[highest_emitting_person, 'salary_value']/bts.full_insee_table.loc[lowest_emitting_person, 'salary_value']) + '}' +eol)
    file.write('\\newcommand\\lowestcarbonintensity{' + "{:.1f}".format(bts.dic_to_emission_content_A35[lowest_emitting_sector]) +'}' + eol)
    file.write('\\newcommand\\highestcarbonintensity{' + "{:.0f}".format(bts.dic_to_emission_content_A35[highest_emitting_sector]) +'}' + eol)
        






#check if there is a person of the highest income classes from the lowest emitting sector and a person of the lowest income classes there from the highest emitting sector
if ((23 in bts.full_insee_table[bts.full_insee_table['A35']==lowest_emitting_sector]['TRNNETO'].unique()) and (0 in bts.full_insee_table[bts.full_insee_table['A35']==highest_emitting_sector]['TRNNETO'].unique() )):
    with open(OUTPUTS_PATH+'section_inequalities_numbers.tex','a') as file:
        file.write('\\newcommand\\ratioofemissions{' + "{:.2f}".format(((bts.dic_TRNNETO_to_salary[23]*bts.dic_to_emission_content_A35[lowest_emitting_sector])/(bts.dic_TRNNETO_to_salary[0]*bts.dic_to_emission_content_A35[highest_emitting_sector]))[0]) + '}' +eol)
        file.write('\\newcommand\\ratioofwages{'+"{:.2f}".format((bts.dic_TRNNETO_to_salary[23]/bts.dic_TRNNETO_to_salary[0])[0])+'}' +eol)
else:
    print('Extreme reversal of inequalities from wages to income-based emissions has not been found')

#

##compute share of wages captured by each class
wage_captured = ut.share_generic('salary_value',bts.full_insee_table,['TRNNETO'])

emis_captured = ut.share_generic('income-based_emissions',bts.full_insee_table,['TRNNETO'])
with open(OUTPUTS_PATH+'section_inequalities_numbers.tex','a') as file:
    file.write('\\newcommand\\sharewageslowestwages{' + "{:.1f}".format(np.sum(wage_captured['share_of_salary_value'][:10]) ) + '}' +eol)
    file.write('\\newcommand\\sharewageshighestwages{' + "{:.1f}".format(wage_captured.loc[23,'share_of_salary_value']) + '}' +eol)
    file.write('\\newcommand\\shareemislowestwages{' + "{:.1f}".format(np.sum(emis_captured['share_of_income-based_emissions'][:10]) ) + '}' +eol)
    file.write('\\newcommand\\shareemishighestwages{' + "{:.1f}".format(emis_captured.loc[23,'share_of_income-based_emissions']) + '}' +eol)

##############
#regression 
##############

def estimate_OLS(X):
    X2=sm.add_constant(X)
    est=sm.OLS(np.array(bts.full_insee_table['log_emission_content']),X2)
    return est.fit()


#regression of emission content against salary
est_wages_alone = estimate_OLS( np.array(bts.full_insee_table['log_salary_value']).reshape((-1,1)))
#print('Regressing mean emission content against log of wages')
#print(est_wages_alone.summary())

#regression of emission content against sexe
est_sex_alone = estimate_OLS( np.array(bts.full_insee_table['SEXE']).reshape((-1,1)))
#print('Regressing mean emission content against sex')
#print(est_sex_alone.summary())

with open(OUTPUTS_PATH+'section_inequalities_numbers.tex','a') as file:
    file.write('\\newcommand\\slopebeta{' + "{:.4f}".format(est_wages_alone.params[1]) + '}' +eol)
    file.write('\\newcommand\\slopebetapercent{' + "{:.2f}".format(est_wages_alone.params[1]) + '}' +eol)
    file.write('\\newcommand\\elasticityibemissions{' + "{:.2f}".format(1+est_wages_alone.params[1]) + '}' +eol)
    file.write('\\newcommand\\slopebetastderr{' + "{:.3f}".format(est_wages_alone.bse[1]) + '}' +eol)
    file.write('\\newcommand\\rsquaredregressionwages{' + "{:.3f}".format(est_wages_alone.rsquared) + '}' +eol)
    file.write('\\newcommand\\diffemisbysexlogpoint{' + "{:.2f}".format(est_sex_alone.params[1]) + '}' +eol)


#get several parameters
#est_salary_alone.params #coefficient of regression
#est_salary_alone.pvalues #p-values
#est_salary_alone.conf_int #confidence interval of coefficient


#regression of emission content against wages and sexe
est_wages_and_sex = estimate_OLS( bts.full_insee_table[['log_salary_value','SEXE']])
#print('Regressing mean emission content against wages and sex')
#print(est_wages_and_sex.summary())

df = summary_col([est_wages_and_sex], stars=True,float_format='%0.3f',info_dict={'$R^2$':lambda x: "{:.3f}".format(x.rsquared)})
latex_str = df.as_latex()
list_of_line = latex_str.split(eol)

#then tweak the string to format as wanted
with open(OUTPUTS_PATH+'econometric_results.tex','w') as file:
    file.write('\\begin{tabular}{N{3cm}N{2cm}}'+eol)
    file.write('\\toprule'+eol)
    file.write('dependent variable & log carbon intensity\\\\'+eol)
    file.write('\\midrule'+eol)
    file.write('log wage' + ''.join(list_of_line[9].partition('&')[1:]) + eol)
    file.write(list_of_line[10] + eol)
    file.write('female employee' + ''.join(list_of_line[11].partition('&')[1:]) + eol)
    file.write(list_of_line[12] + eol)
    file.write('intercept' + ''.join(list_of_line[7].partition('&')[1:]) + eol)
    file.write(list_of_line[8] + eol)
    file.write('\\midrule'+eol)
    file.write(list_of_line[15].replace('\\$','$') + eol)
    file.write('\\bottomrule'+eol)
    file.write('\\end{tabular}'+eol)
    file.close()


#regression of wages against sex to have the difference in log point
X=np.array(bts.full_insee_table['SEXE']).reshape((-1,1))
X2=sm.add_constant(X)
est=sm.OLS(np.array(bts.full_insee_table['log_salary_value']),X2)
est_wages_against_sex = est.fit()
#print(est_wages_against_sex.summary())
with open(OUTPUTS_PATH+'section_inequalities_numbers.tex','a') as file:
    file.write('\\newcommand\\diffwagesbysexlogpoint{' + "{:.2f}".format(est_wages_against_sex.params[1]) + '}' +eol)


#build the frequency matrix if independent
X='A35'
Y='SEXE'
cont = bts.full_insee_table[[X,Y]].pivot_table(index=X,columns=Y,aggfunc=len,margins=True,margins_name="Total")
c = cont.fillna(0)
##compute the contingency matrix in case of independence
tx = cont.loc[:,["Total"]]
ty = cont.loc[["Total"],:]
n = len(bts.full_insee_table)
indep = tx.dot(ty) / n
#compute xi2 by hand, ok to include margins, as they are zero here
measure = (c-indep)**2/indep
xi_n = measure.sum().sum() #this is the same as st_chi2
#picture the matrix of gap
table = measure/xi_n
sns.heatmap(table.iloc[:-1,:-1])#,annot=c.iloc[:-1,:-1])
#plt.show()
plt.close()
#three striking sector

#share captured by women
pop_share = ut.share_generic('POND',bts.full_insee_table,['SEXE'])
wage_share = ut.share_generic('salary_value',bts.full_insee_table,['SEXE'])
emis_share = ut.share_generic('income-based_emissions',bts.full_insee_table,['SEXE'])

with open(OUTPUTS_PATH+'share-captured-by-gender.tex','w') as file:
    file.write('\\begin{tabular}{L{1.5cm}L{2cm}L{2cm}L{3cm}}'+eol)
    file.write('\\toprule'+eol)
    file.write('& share of population & share of wages earned & share of income-based emissions \\\\'+eol)
    file.write('\\midrule'+eol)
    file.write('men &' + "{:.1f}".format(pop_share.iloc[0,1]) + '&'+"{:.1f}".format(wage_share.iloc[0,1]) +'&'+"{:.1f}".format(emis_share.iloc[0,1]) +'\\\\' +eol)
    file.write('women &' + "{:.1f}".format(pop_share.iloc[1,1]) + '&'+"{:.1f}".format(wage_share.iloc[1,1]) +'&'+"{:.1f}".format(emis_share.iloc[1,1]) +'\\\\' +eol)
    file.write('\\bottomrule'+eol)
    file.write('\\end{tabular}'+eol)


#employment of women by working condition
working_condition_by_sex=bts.full_insee_table.groupby(['CPFD','SEXE']).apply(len).reset_index()
working_condition_by_sex['proportion_by_sex']= pd.concat((working_condition_by_sex[working_condition_by_sex['SEXE']==1][0]/np.sum(working_condition_by_sex[working_condition_by_sex['SEXE']==1][0]), working_condition_by_sex[working_condition_by_sex['SEXE']==2][0]/np.sum(working_condition_by_sex[working_condition_by_sex['SEXE']==2][0])))

#difference of wages at full time jobs
full_time_table=bts.full_insee_table[bts.full_insee_table['CPFD']=='C']
X=np.array(full_time_table['SEXE']).reshape((-1,1))
X2=sm.add_constant(X)
est=sm.OLS(np.array(full_time_table['log_salary_value']),X2)
est_wages_against_sex = est.fit()
#print(est_wages_against_sex.summary())
with open(OUTPUTS_PATH+'section_inequalities_numbers.tex','a') as file:
    file.write('\\newcommand\\diffwagesbysexfulltimelogpoint{' + "{:.2f}".format(est_wages_against_sex.params[1]) + '}' +eol)
    file.write('\\newcommand\\percentmenfulltime{' + "{:.1f}".format(working_condition_by_sex[(working_condition_by_sex['CPFD']=='C')&(working_condition_by_sex['SEXE']==1)]['proportion_by_sex'].values[0]*100) + '}' +eol)
    file.write('\\newcommand\\percentwomenfulltime{' + "{:.1f}".format(working_condition_by_sex[(working_condition_by_sex['CPFD']=='C')&(working_condition_by_sex['SEXE']==2)]['proportion_by_sex'].values[0]*100) + '}' +eol)


## PLOT
sns.set_context('paper', font_scale=0.9)

mean_emis_content_by_class = ut.stat_data_generic(['TRNNETO'],bts.full_insee_table, ut.mean_emission_content)

#lowest and highest value per income class
mean_carbon_intensity_by_class = mean_emis_content_by_class['mean emission content'][24]
min_carbon_intensity_by_class = min(mean_emis_content_by_class['mean emission content'])
min_gap_to_mean = 100*( 1- min_carbon_intensity_by_class/mean_carbon_intensity_by_class)
max_carbon_intensity_by_class = max(mean_emis_content_by_class['mean emission content'])
max_gap_to_mean = 100*( max_carbon_intensity_by_class/mean_carbon_intensity_by_class -1)

with open(OUTPUTS_PATH+'section_inequalities_numbers.tex','a') as file:
    file.write('\\newcommand\\meancarbonintensityclass{' + "{:.0f}".format(mean_carbon_intensity_by_class) + '}' +eol)
    file.write('\\newcommand\\mincarbonintensityclass{' + "{:.0f}".format(min_carbon_intensity_by_class) + '}' +eol)
    file.write('\\newcommand\\mingaptomean{' + "{:.0f}".format(min_gap_to_mean) + '}' +eol)
    file.write('\\newcommand\\maxcarbonintensityclass{' + "{:.0f}".format(max_carbon_intensity_by_class) + '}' +eol)
    file.write('\\newcommand\\maxgaptomean{' + "{:.0f}".format(max_gap_to_mean) + '}' +eol)


#plot for mean emission content by wage classes
plt.figure(figsize=(18, 12))
sns.barplot(x=mean_emis_content_by_class['TRNNETO'], y="mean emission content", data=mean_emis_content_by_class,palette='deep')
plt.xlabel("wage class", size=12)
plt.ylabel("gCO2/euro", size=12)
#plt.title("Mean carbon intensity by wage classes", size=12)
plt.savefig(OUTPUTS_PATH+'fig_mean_emis_cont_by_class.jpeg', bbox_inches='tight')



#statistiques by sex and class
#les femmes ont un contenu en émissions beaucoup plus faibles que les hommes
sex_emission_content = ut.stat_data_generic(['SEXE'],bts.full_insee_table, ut.mean_emission_content)
with open(OUTPUTS_PATH+'section_inequalities_numbers.tex','a') as file:
    file.write('\\newcommand\\carbonintensitymalework{' + "{:.0f}".format(sex_emission_content[sex_emission_content['SEXE']==1]['mean emission content'].values[0]) + '}' +eol)
    file.write('\\newcommand\\carbonintensityfemalework{' + "{:.0f}".format(sex_emission_content[sex_emission_content['SEXE']==2]['mean emission content'].values[0]) + '}' +eol)
#test of the evolution of emission content by sex when some sectors are removed
#sex_emission_content = ut.stat_data_generic(['SEXE'],bts.full_insee_table[(bts.full_insee_table['A35'] != 'QA-QB') & (bts.full_insee_table['A35'] != 'PZ') & (bts.full_insee_table['A35'] != 'FZ')& (bts.full_insee_table['A35'] != 'HZ')], ut.mean_emission_content)




#sur chaque ligne, pour une population caractérisée par son sexe, on a la liste des proportions (pondérées par les salaires) employées dans les différentes secteurs, c'est-à-dire la part des salaires captée par chaque sexe en fonction du secteur d'activité
relative_pop = ut.stat_data_generic(['SEXE'],bts.full_insee_table, lambda x: ut.proportion_generic_weighted(x,'A35'))
relative_pop['SEXE'].replace({1:'Male',2:'Female'},inplace=True)
relative_pop.set_index(['SEXE'], inplace=True)
diff_share_pop = relative_pop.xs('Male', axis=0) - relative_pop.xs('Female', axis=0)

table_diff_pop = pd.DataFrame({'A35':diff_share_pop.index, 'diff wage share':diff_share_pop.values})
table_diff_pop['mean emission content'] = table_diff_pop['A35'].replace(bts.dic_to_emission_content_A35)
table_diff_pop.sort_values(by='mean emission content', inplace=True)


## Plot histo diff gender in share accross branch - Graph ALL mean
fig, ax1 = plt.subplots(figsize=(18, 12)) # initializes figure and plots
#ax2 = ax1.twinx() # applies twinx to ax2, which is the second y axis. 
ax2 = ax1.twinx()
f1 =sns.barplot(x='A35', y="diff wage share", data=table_diff_pop, ax = ax1, palette='deep') # plots the first set of data, and sets it to ax1. 
f2= sns.scatterplot(x ='A35', y ='mean emission content', data=table_diff_pop, marker='o', ax = ax2, color="firebrick", s=80) # plots the second set, and sets to ax2. 
ax1.set_xlabel('branches', size=14)
ax1.set_ylabel('Gap between male and female population share (%)', size=14)
ax2.set_ylabel('carbon intensity in gCO2/euro', size=14)
plt.title("wage group", size=14)
plt.savefig(OUTPUTS_PATH+'fig_relative_pop_and_intensity_by_industry.jpeg', bbox_inches='tight')
#plt.show()
plt.close()
