# -*- coding: utf-8 -*-
"""
Éditeur de Spyder

Ceci est un script temporaire.
"""
import os
import pandas as pd
import scipy.stats as st
import numpy as np
#import matplotlib.pyplot as plt
#import seaborn as sns
import utils as ut
import statsmodels.api as sm
from statsmodels.iolib.summary2 import summary_col
import build_table_survey as bts
from scipy import interpolate

##########################
###### Paths 
##########################
output_folder='outputs'
#create output_folder if not exist
if not os.path.exists(output_folder):
    os.makedirs(output_folder)
    print('Creating ' + output_folder + ' to store outputs')
output_path = output_folder + os.sep

data_folder = 'data'
data_path = data_folder + os.sep

this_file = 'eco_gender_analysis.py'
eol='\n'


#######################
# statistical test of independence between branches and wage classes
#######################

#build the frequency matrix if independent
X='A38'
Y='TRNNETO'
cont = bts.full_insee_table[[X,Y]].pivot_table(index=X,columns=Y,aggfunc=len,margins=True,margins_name="Total")
c = cont.fillna(0)
#chi-squared test of independence
# do not include margins in contingency matrix, otherwise the dof are not accurate
st_chi2, st_p, st_dof, st_exp = st.chi2_contingency(c.iloc[:-1,:-1])

##chi2 by hand
##compute the contingency matrix in case of independence
#tx = cont.loc[:,["Total"]]
#ty = cont.loc[["Total"],:]
#n = len(bts.full_insee_table)
#indep = tx.dot(ty) / n
##compute xi2 by hand, ok to include margins, as they are zero here
#measure = (c-indep)**2/indep
#xi_n = measure.sum().sum() #this is the same as st_chi2
##picture the matrix of gap
#table = measure/xi_n
#sns.heatmap(table.iloc[:-1,:-1])#,annot=c.iloc[:-1,:-1])
#plt.show()


#comparison of variance of log of income-based emissions with sums of variance of log of carbon intensity and of log of wages
bts.full_insee_table['log_income-based_emissions'] = np.log(bts.full_insee_table['income-based_emissions'])
bts.full_insee_table['log_carbon_intensity'] = np.log(bts.full_insee_table['carbon_intensity'])
bts.full_insee_table['log_salary_value'] = np.log(bts.full_insee_table['salary_value'])

matrix = np.cov(np.transpose(np.array(bts.full_insee_table[['log_carbon_intensity','log_salary_value']])))
relative_matrix = matrix /np.sum(matrix)
with open(output_path+'decomposition_variance.tex','w') as file:
    file.write('% file automatically generated by ' + this_file + eol)
    file.write('% decomposition of variance of log of emission-based' + eol)
    file.write('\\intertext{or in numbers}'+eol)
    file.write("{:.2f}".format(np.sum(matrix)) + " &= " + "{:.2f}".format(matrix[0,0]) +" &&+ " + "{:.2f}".format(matrix[1,1]) + " &&+ 2\cdot" +"{:.2f}".format(matrix[0,1]) + eol)
    file.write('\\intertext{which can also be expressed in relative terms}'+eol)
    file.write("{:.2f}".format(np.sum(relative_matrix)) + " &= " + "{:.2f}".format(relative_matrix[0,0]) +" &&+ " + "{:.2f}".format(relative_matrix[1,1]) + " &&+ 2\cdot" +"{:.2f}".format(relative_matrix[0,1]))

with open(output_path+'section_inequalities_numbers.tex','w') as file:
    file.write('% file automatically generated by ' + this_file + eol)
    file.write('% numbers used in main text' + eol)
    file.write('\\newcommand\\relativeratioofvariance{' + "{:.2f}".format(matrix[0,0]/matrix[1,1]) + '} %ratio of variance of log of emissions divided by variance of log of wages' + eol)

#################
# Lorenz and concentration curves
#################

#construct the data for Lorenz curves from grouping by wage classes and branches (because that is all what matters)
bts.full_insee_table['pop_mass']=1
pop_mass_per_sector_x_salary=bts.full_insee_table.groupby(['TRNNETO','A35']).size().reset_index(name='pop_mass')
pop_mass_per_sector_x_salary['carbon_intensity'] = pop_mass_per_sector_x_salary['A35'].replace(bts.dic_to_carbon_intensity_A35)
pop_mass_per_sector_x_salary['salary_value'] = pop_mass_per_sector_x_salary['TRNNETO'].replace(bts.dic_TRNNETO_to_salary)
pop_mass_per_sector_x_salary['salary_mass'] = pop_mass_per_sector_x_salary['salary_value'] * pop_mass_per_sector_x_salary['pop_mass']
pop_mass_per_sector_x_salary['emissions_mass'] = pop_mass_per_sector_x_salary['salary_mass'] * pop_mass_per_sector_x_salary['carbon_intensity']
pop_mass_per_sector_x_salary['emissions_capita'] = pop_mass_per_sector_x_salary['salary_value'] * pop_mass_per_sector_x_salary['carbon_intensity']

Lorenz_curve_data = ut.make_Lorenz_and_concentration_curves(np.transpose(np.array(pop_mass_per_sector_x_salary[['pop_mass','salary_value', 'emissions_capita']])),{'pop_mass':0,'income':1,'emissions':2},output_path + 'Lorenz_curve_French_employee','% data for Lorenz and concentration curves for French employees \n% file automatically created from ' + this_file )
tck_income = interpolate.splrep(Lorenz_curve_data['pop_cum_by_income'], Lorenz_curve_data['income_cum_by_income'])
tck_emissions = interpolate.splrep(Lorenz_curve_data['pop_cum_by_emissions'],Lorenz_curve_data['emissions_cum_by_emissions'])




#lowest emitting person
lowest_emitting_person = bts.full_insee_table['income-based_emissions'].idxmin()
#highest emitting person
highest_emitting_person = bts.full_insee_table['income-based_emissions'].idxmax()
#lowest emitting sector 
lowest_emitting_sector = min(bts.dic_to_carbon_intensity_A35, key=bts.dic_to_carbon_intensity_A35.get)
#highest emitting sector 
highest_emitting_sector = max(bts.dic_to_carbon_intensity_A35, key=bts.dic_to_carbon_intensity_A35.get)

with open(output_path+'section_inequalities_numbers.tex','a') as file:
    file.write('\\newcommand\\ratioofemissionshighestlowest{' + "{:.0f}".format(bts.full_insee_table.loc[highest_emitting_person, 'income-based_emissions']/bts.full_insee_table.loc[lowest_emitting_person, 'income-based_emissions']) + '}' +eol)
    file.write('\\newcommand\\ratioofwageshighestlowest{' + "{:.0f}".format(bts.full_insee_table.loc[highest_emitting_person, 'salary_value']/bts.full_insee_table.loc[lowest_emitting_person, 'salary_value']) + '}' +eol)
    file.write('\\newcommand\\lowestcarbonintensity{' + "{:.1f}".format(bts.dic_to_carbon_intensity_A35[lowest_emitting_sector]) +'}' + eol)
    file.write('\\newcommand\\highestcarbonintensity{' + "{:.0f}".format(bts.dic_to_carbon_intensity_A35[highest_emitting_sector]) +'}' + eol)
    file.write('\\newcommand\\ratiowagesTB{' + "{:.1f}".format(interpolate.splev(0.9,tck_income)/interpolate.splev(0.1,tck_income)) +'}' + eol)
    file.write('\\newcommand\\ratioemissionTB{' + "{:.1f}".format(interpolate.splev(0.9,tck_emissions)/interpolate.splev(0.1,tck_emissions)) +'}' + eol)
        






#check if there is a person of the highest income classes from the lowest emitting sector and a person of the lowest income classes there from the highest emitting sector
if ((23 in bts.full_insee_table[bts.full_insee_table['A35']==lowest_emitting_sector]['TRNNETO'].unique()) and (0 in bts.full_insee_table[bts.full_insee_table['A35']==highest_emitting_sector]['TRNNETO'].unique() )):
    with open(output_path+'section_inequalities_numbers.tex','a') as file:
        file.write('\\newcommand\\ratioofemissions{' + "{:.2f}".format(((bts.dic_TRNNETO_to_salary[23]*bts.dic_to_carbon_intensity_A35[lowest_emitting_sector])/(bts.dic_TRNNETO_to_salary[0]*bts.dic_to_carbon_intensity_A35[highest_emitting_sector]))[0]) + '}' +eol)
        file.write('\\newcommand\\ratioofwages{'+"{:.2f}".format((bts.dic_TRNNETO_to_salary[23]/bts.dic_TRNNETO_to_salary[0])[0])+'}' +eol)
else:
    print('Extreme reversal of inequalities from wages to income-based emissions has not been found')

#

##compute share of wages captured by each class
wage_captured = ut.share_generic('salary_value',bts.full_insee_table,['TRNNETO'])

emis_captured = ut.share_generic('income-based_emissions',bts.full_insee_table,['TRNNETO'])
with open(output_path+'section_inequalities_numbers.tex','a') as file:
    file.write('\\newcommand\\sharewageslowestwages{' + "{:.1f}".format(np.sum(wage_captured['share_of_salary_value'][:10]) ) + '}' +eol)
    file.write('\\newcommand\\sharewageshighestwages{' + "{:.1f}".format(wage_captured.loc[23,'share_of_salary_value']) + '}' +eol)
    file.write('\\newcommand\\shareemislowestwages{' + "{:.1f}".format(np.sum(emis_captured['share_of_income-based_emissions'][:10]) ) + '}' +eol)
    file.write('\\newcommand\\shareemishighestwages{' + "{:.1f}".format(emis_captured.loc[23,'share_of_income-based_emissions']) + '}' +eol)

#test to aggregate PCS according to Dalvit, but yields too low sample for High Skilled
dic_CS_to_skill={10:'High', 21:'High', 22:'High', 23:'High', 31:'Medium-H', 33.:'Medium-H', 34.:'Medium-H', 35.:'Medium-H', 37.:'Medium-H', 38.:'Medium-H', 42.:'Medium-L', 43.:'Medium-L', 44.:'Medium-L',
        45.:'Medium-L', 46.:'Medium-L', 47.:'Medium-L', 48.:'Medium-L', 52.:'Low', 53.:'Low', 54.:'Low', 55.:'Low', 56.:'Low', 62.:'Low', 63.:'Low', 64.:'Low', 65.:'Low',
       67.:'Low', 68.:'Low', 69.:'Low'}
bts.full_insee_table['Skill']=bts.full_insee_table['CS'].replace(dic_CS_to_skill)
ut.stat_data_generic(['Skill'],bts.full_insee_table, ut.mean_carbon_intensity)

##############
#regression 
##############

def estimate_OLS(X):
    X2=sm.add_constant(X)
    est=sm.OLS(np.array(bts.full_insee_table['log_carbon_intensity']),X2)
    return est.fit()


#regression of carbon intensity against salary
est_wages_alone = estimate_OLS( np.array(bts.full_insee_table['log_salary_value']).reshape((-1,1)))
#print('Regressing mean carbon intensity against log of wages')
#print(est_wages_alone.summary())

#regression of carbon intensity against sexe
est_sex_alone = estimate_OLS( np.array(bts.full_insee_table['SEXE']).reshape((-1,1)))
#print('Regressing mean carbon intensity against sex')
#print(est_sex_alone.summary())

with open(output_path+'section_inequalities_numbers.tex','a') as file:
    file.write('\\newcommand\\slopebeta{' + "{:.4f}".format(est_wages_alone.params[1]) + '}' +eol)
    file.write('\\newcommand\\slopebetapercent{' + "{:.2f}".format(est_wages_alone.params[1]) + '}' +eol)
    file.write('\\newcommand\\elasticityibemissions{' + "{:.2f}".format(1+est_wages_alone.params[1]) + '}' +eol)
    file.write('\\newcommand\\slopebetastderr{' + "{:.4f}".format(est_wages_alone.bse[1]) + '}' +eol)
    file.write('\\newcommand\\rsquaredregressionwages{' + "{:.3f}".format(est_wages_alone.rsquared) + '}' +eol)
    file.write('\\newcommand\\diffemisbysexlogpoint{' + "{:.2f}".format(est_sex_alone.params[1]) + '}' +eol)


#get several parameters
#est_salary_alone.params #coefficient of regression
#est_salary_alone.pvalues #p-values
#est_salary_alone.conf_int #confidence interval of coefficient


#regression of carbon intensity against wages and sexe
est_wages_and_sex = estimate_OLS( bts.full_insee_table[['log_salary_value','SEXE']])
#print('Regressing mean carbon intensity against wages and sex')
#print(est_wages_and_sex.summary())

df = summary_col([est_wages_and_sex], stars=True,float_format='%0.3f',info_dict={'$R^2$':lambda x: "{:.3f}".format(x.rsquared)})
latex_str = df.as_latex()
list_of_line = latex_str.split(eol)

#then tweak the string to format as wanted
with open(output_path+'econometric_results.tex','w') as file:
    file.write('\\begin{tabular}{N{3cm}N{2cm}}'+eol)
    file.write('\\toprule'+eol)
    file.write('dependent variable & log carbon intensity\\\\'+eol)
    file.write('\\midrule'+eol)
    file.write('log wage' + ''.join(list_of_line[9].partition('&')[1:]) + eol)
    file.write(list_of_line[10] + eol)
    file.write('female employee' + ''.join(list_of_line[11].partition('&')[1:]) + eol)
    file.write(list_of_line[12] + eol)
    file.write('intercept' + ''.join(list_of_line[7].partition('&')[1:]) + eol)
    file.write(list_of_line[8] + eol)
    file.write('\\midrule'+eol)
    file.write(list_of_line[15].replace('\\$','$') + eol)
    file.write('\\bottomrule'+eol)
    file.write('\\end{tabular}'+eol)
    file.close()
with open(output_path+'section_inequalities_numbers.tex','a') as file:
    file.write('\\newcommand\\slopebetawithgender{' + "{:.4f}".format(est_wages_and_sex.params['log_salary_value']) + '}' +eol)
    file.write('\\newcommand\\slopebetastderrwithgender{' + "{:.4f}".format(est_wages_and_sex.bse['log_salary_value']) + '}' +eol)
    file.write('\\newcommand\\slopegammawithgender{' + "{:.4f}".format(est_wages_and_sex.params['SEXE']) + '}' +eol)
    file.write('\\newcommand\\slopegammastderrwithgender{' + "{:.4f}".format(est_wages_and_sex.bse['SEXE']) + '}' +eol)
    file.write('\\newcommand\\rsquaredwithgender{' + "{:.3f}".format(est_wages_and_sex.rsquared) + '}' +eol)


#regression of wages against sex to have the difference in log point
X=np.array(bts.full_insee_table['SEXE']).reshape((-1,1))
X2=sm.add_constant(X)
est=sm.OLS(np.array(bts.full_insee_table['log_salary_value']),X2)
est_wages_against_sex = est.fit()
#print(est_wages_against_sex.summary())
with open(output_path+'section_inequalities_numbers.tex','a') as file:
    file.write('\\newcommand\\diffwagesbysexlogpoint{' + "{:.2f}".format(est_wages_against_sex.params[1]) + '}' +eol)


##build the frequency matrix if independent
#X='A35'
#Y='SEXE'
#cont = bts.full_insee_table[[X,Y]].pivot_table(index=X,columns=Y,aggfunc=len,margins=True,margins_name="Total")
#c = cont.fillna(0)
###compute the contingency matrix in case of independence
#tx = cont.loc[:,["Total"]]
#ty = cont.loc[["Total"],:]
#n = len(bts.full_insee_table)
#indep = tx.dot(ty) / n
##compute xi2 by hand, ok to include margins, as they are zero here
#measure = (c-indep)**2/indep
#xi_n = measure.sum().sum() #this is the same as st_chi2
##picture the matrix of gap
#table = measure/xi_n
#sns.heatmap(table.iloc[:-1,:-1])#,annot=c.iloc[:-1,:-1])
##plt.show()
#plt.close()
##three striking sectors

#share captured by women
pop_share = ut.share_generic('POND',bts.full_insee_table,['SEXE'])
wage_share = ut.share_generic('salary_value',bts.full_insee_table,['SEXE'])
emis_share = ut.share_generic('income-based_emissions',bts.full_insee_table,['SEXE'])

with open(output_path+'share-captured-by-gender.tex','w') as file:
    file.write('\\begin{tabular}{L{1.5cm}L{2cm}L{2cm}L{3cm}}'+eol)
    file.write('\\toprule'+eol)
    file.write('& share of population & share of wages earned & share of income-based emissions \\\\'+eol)
    file.write('\\midrule'+eol)
    file.write('men &' + "{:.1f}".format(pop_share.iloc[0,1]) + '&'+"{:.1f}".format(wage_share.iloc[0,1]) +'&'+"{:.1f}".format(emis_share.iloc[0,1]) +'\\\\' +eol)
    file.write('women &' + "{:.1f}".format(pop_share.iloc[1,1]) + '&'+"{:.1f}".format(wage_share.iloc[1,1]) +'&'+"{:.1f}".format(emis_share.iloc[1,1]) +'\\\\' +eol)
    file.write('\\bottomrule'+eol)
    file.write('\\end{tabular}'+eol)


#employment of women by working condition
working_condition_by_sex=bts.full_insee_table.groupby(['CPFD','SEXE']).apply(len).reset_index()
working_condition_by_sex['proportion_by_sex']= pd.concat((working_condition_by_sex[working_condition_by_sex['SEXE']==1][0]/np.sum(working_condition_by_sex[working_condition_by_sex['SEXE']==1][0]), working_condition_by_sex[working_condition_by_sex['SEXE']==2][0]/np.sum(working_condition_by_sex[working_condition_by_sex['SEXE']==2][0])))

#difference of wages at full time jobs
full_time_table=bts.full_insee_table[bts.full_insee_table['CPFD']=='C']
X=np.array(full_time_table['SEXE']).reshape((-1,1))
X2=sm.add_constant(X)
est=sm.OLS(np.array(full_time_table['log_salary_value']),X2)
est_wages_against_sex = est.fit()
#print(est_wages_against_sex.summary())
with open(output_path+'section_inequalities_numbers.tex','a') as file:
    file.write('\\newcommand\\diffwagesbysexfulltimelogpoint{' + "{:.2f}".format(est_wages_against_sex.params[1]) + '}' +eol)
    file.write('\\newcommand\\percentmenfulltime{' + "{:.1f}".format(working_condition_by_sex[(working_condition_by_sex['CPFD']=='C')&(working_condition_by_sex['SEXE']==1)]['proportion_by_sex'].values[0]*100) + '}' +eol)
    file.write('\\newcommand\\percentwomenfulltime{' + "{:.1f}".format(working_condition_by_sex[(working_condition_by_sex['CPFD']=='C')&(working_condition_by_sex['SEXE']==2)]['proportion_by_sex'].values[0]*100) + '}' +eol)

#regression of wages against sex, controlled by full-time job and industries
D = pd.get_dummies(full_time_table['A35'])
sex_with_industry_dummies = full_time_table[['SEXE']].join(D.loc[:,D.columns!='AZ'] ) #'AZ' is the reference industry
X3=sm.add_constant(np.array(sex_with_industry_dummies))
est=sm.OLS(np.array(full_time_table['log_salary_value']),X3)
est_wages_against_sex_and_industries = est.fit()
#gender pay gap is still significant when industry is controlled for

carbon_intensity_by_class = ut.stat_data_generic(['TRNNETO'],bts.full_insee_table, ut.mean_carbon_intensity)
dic_TRNNETO_to_range = {0 : "[0,0.2[",1 : "[0.2,0.5[",2 : "[0.5,1[",3 : "[1,1.5[",4 : "[1.5,2[",5 : "[2,3[",6 : "[3,4[",7 : "[4,6[",8 : "[6,8[",9 : "[8,10[",10 : "[10,12[", 11 : "[12,14[",12 : "[14,16[", 13 : "[16,18[", 14 : "[18,20[", 15 : "[20,22[", 16 : "[22,24[", 17 : "[24,26[", 18 : "[26,28[",19 : "[28,30[",20 : "[30,35[", 21 : "[35,40[", 22 : "[40,50[", 23: "[50, + ["}
carbon_intensity_by_class['TRNNETO']=carbon_intensity_by_class['TRNNETO'].replace(dic_TRNNETO_to_range)
carbon_intensity_by_class.set_index(['TRNNETO'], inplace=True)

#lowest and highest value per income class
mean_carbon_intensity_by_class = carbon_intensity_by_class['mean carbon intensity']['All']
min_carbon_intensity_by_class = min(carbon_intensity_by_class['mean carbon intensity'])
min_gap_to_mean = 100*( 1- min_carbon_intensity_by_class/mean_carbon_intensity_by_class)
max_carbon_intensity_by_class = max(carbon_intensity_by_class['mean carbon intensity'])
max_gap_to_mean = 100*( max_carbon_intensity_by_class/mean_carbon_intensity_by_class -1)

with open(output_path+'section_inequalities_numbers.tex','a') as file:
    file.write('\\newcommand\\meancarbonintensityclass{' + "{:.0f}".format(mean_carbon_intensity_by_class) + '}' +eol)
    file.write('\\newcommand\\mincarbonintensityclass{' + "{:.0f}".format(min_carbon_intensity_by_class) + '}' +eol)
    file.write('\\newcommand\\mingaptomean{' + "{:.0f}".format(min_gap_to_mean) + '}' +eol)
    file.write('\\newcommand\\maxcarbonintensityclass{' + "{:.0f}".format(max_carbon_intensity_by_class) + '}' +eol)
    file.write('\\newcommand\\maxgaptomean{' + "{:.0f}".format(max_gap_to_mean) + '}' +eol)


ut.df_to_csv_with_comment( carbon_intensity_by_class, output_path + 'carbon_intensity_by_wage_class.csv', '% file automatically generated by ' + this_file + eol + '% downstream carbon intensity by wage classes', sep=';')

##plot now done with pgfplots in Latex
##plot for mean carbon intensity by wage classes
#sns.set_context('paper', font_scale=0.9)
#plt.figure(figsize=(18, 12))
#sns.barplot(x=carbon_intensity_by_class['TRNNETO'], y="mean carbon intensity", data=carbon_intensity_by_class,palette='deep')
#plt.xlabel("wage class", size=12)
#plt.ylabel("gCO2/euro", size=12)
##plt.title("Mean carbon intensity by wage classes", size=12)
#plt.savefig(output_path+'fig_mean_emis_cont_by_class.jpeg', bbox_inches='tight')



#statistiques by sex and class
#les femmes ont un contenu en émissions beaucoup plus faibles que les hommes
sex_carbon_intensity = ut.stat_data_generic(['SEXE'],bts.full_insee_table, ut.mean_carbon_intensity)
with open(output_path+'section_inequalities_numbers.tex','a') as file:
    file.write('\\newcommand\\carbonintensitymalework{' + "{:.0f}".format(sex_carbon_intensity[sex_carbon_intensity['SEXE']==1]['mean carbon intensity'].values[0]) + '}' +eol)
    file.write('\\newcommand\\carbonintensityfemalework{' + "{:.0f}".format(sex_carbon_intensity[sex_carbon_intensity['SEXE']==2]['mean carbon intensity'].values[0]) + '}' +eol)
#test of the evolution of carbon intensity by sex when some sectors are removed
#sex_carbon_intensity = ut.stat_data_generic(['SEXE'],bts.full_insee_table[(bts.full_insee_table['A35'] != 'QA-QB') & (bts.full_insee_table['A35'] != 'PZ') & (bts.full_insee_table['A35'] != 'FZ')& (bts.full_insee_table['A35'] != 'HZ')], ut.mean_carbon_intensity)




#sur chaque ligne, pour une population caractérisée par son sexe, on a la liste des proportions (pondérées par les salaires) employées dans les différentes secteurs, c'est-à-dire la part des salaires captée par chaque sexe en fonction du secteur d'activité
relative_wage_share = ut.stat_data_generic(['SEXE'],bts.full_insee_table, lambda x: ut.proportion_generic_weighted(x,'A35'))
relative_wage_share['SEXE'].replace({1:'Male',2:'Female'},inplace=True)
relative_wage_share.set_index(['SEXE'], inplace=True)
diff_wage_share = relative_wage_share.xs('Male', axis=0) - relative_wage_share.xs('Female', axis=0)

#structural decomposition analysis of diff_wage_share
relative_pop_share = ut.stat_data_generic(['SEXE'],bts.full_insee_table, lambda x: ut.proportion_generic(x,'A35'))
relative_pop_share['SEXE'].replace({1:'Male',2:'Female'},inplace=True)
relative_pop_share.set_index(['SEXE'], inplace=True)

relative_wage = relative_wage_share / relative_pop_share

component_wage= (relative_wage.xs('Male', axis=0) - relative_wage.xs('Female', axis=0) ) *(relative_pop_share.xs('Male', axis=0) + relative_pop_share.xs('Female', axis=0))/2 

component_pop = (relative_wage.xs('Male', axis=0) + relative_wage.xs('Female', axis=0) ) *(relative_pop_share.xs('Male', axis=0) - relative_pop_share.xs('Female', axis=0))/2

#component wage and component pop sum up to diff_wage_share, thus providing a decomposition
#in this decomposition, component_pop is usually the main factor. There are three problematic sectors: GZ, IZ and MA-MC where the component_wage is particularly high

table_diff_pop = pd.DataFrame({'A35':diff_wage_share.index, 'diff wage share':diff_wage_share.values})
table_diff_pop['mean carbon intensity'] = table_diff_pop['A35'].replace(bts.dic_to_carbon_intensity_A35)
table_diff_pop.sort_values(by='mean carbon intensity', inplace=True)

##plot now done with pgfplots
### Plot histo diff gender in share accross branch - Graph ALL mean
#fig, ax1 = plt.subplots(figsize=(18, 12)) # initializes figure and plots
##ax2 = ax1.twinx() # applies twinx to ax2, which is the second y axis. 
#ax2 = ax1.twinx()
#f1 =sns.barplot(x='A35', y="diff wage share", data=table_diff_pop, ax = ax1, palette='deep') # plots the first set of data, and sets it to ax1. 
#f2= sns.scatterplot(x ='A35', y ='mean carbon intensity', data=table_diff_pop, marker='o', ax = ax2, color="firebrick", s=80) # plots the second set, and sets to ax2. 
#ax1.set_xlabel('branches', size=14)
#ax1.set_ylabel('Gap between male and female population share (%)', size=14)
#ax2.set_ylabel('carbon intensity in gCO2/euro', size=14)
#plt.title("wage group", size=14)
#plt.savefig(output_path+'fig_relative_wage_share_and_intensity_by_industry.jpeg', bbox_inches='tight')
##plt.show()
#plt.close()

table_diff_pop.set_index(['A35'], inplace=True)
ut.df_to_csv_with_comment( table_diff_pop, output_path + 'diff_wage_share_by_branch.csv', '% file automatically generated by ' + this_file + eol + '% difference of wage share between male and female workers per sector')

with open(output_path+'section_inequalities_numbers.tex','a') as file:
    file.write('\\newcommand\\carbonintensityHZ{' + "{:.0f}".format(table_diff_pop.loc['HZ','mean carbon intensity']) + '}' +eol)
    file.write('\\newcommand\\diffwageshareHZ{' + "{:.0f}".format(table_diff_pop.loc['HZ','diff wage share']) + '}' +eol)
